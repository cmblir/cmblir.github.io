<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-06-26T18:13:34+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">성장형 개발자 블로그</title><subtitle>An amazing website.</subtitle><author><name>You Nicholas</name></author><entry><title type="html">[파이썬][프로그래머스] 로또의 최고 순위와 최저 순위</title><link href="http://localhost:4000/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/77484/" rel="alternate" type="text/html" title="[파이썬][프로그래머스] 로또의 최고 순위와 최저 순위" /><published>2022-06-26T00:00:00+09:00</published><updated>2022-06-26T00:00:00+09:00</updated><id>http://localhost:4000/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/77484</id><content type="html" xml:base="http://localhost:4000/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/77484/">&lt;h2 id=&quot;1-문제&quot;&gt;1. 문제&lt;/h2&gt;

&lt;h1 id=&quot;level-1-로또의-최고-순위와-최저-순위---77484&quot;&gt;[level 1] 로또의 최고 순위와 최저 순위 - 77484&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/77484&quot;&gt;문제 링크&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;성능-요약&quot;&gt;성능 요약&lt;/h3&gt;

&lt;p&gt;메모리: 10.4 MB, 시간: 0.02 ms&lt;/p&gt;

&lt;h3 id=&quot;구분&quot;&gt;구분&lt;/h3&gt;

&lt;p&gt;코딩테스트 연습 &amp;gt; 2021 Dev－Matching： 웹 백엔드 개발자（상반기）&lt;/p&gt;

&lt;h3 id=&quot;채점결과&quot;&gt;채점결과&lt;/h3&gt;

&lt;p&gt;&lt;br /&gt;정확성: 100.0&lt;br /&gt;합계: 100.0 / 100.0&lt;/p&gt;

&lt;h3 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;로또 6/45&lt;/code&gt;(이하 '로또'로 표기)는 1부터 45까지의 숫자 중 6개를 찍어서 맞히는 대표적인 복권입니다. 아래는 로또의 순위를 정하는 방식입니다. &lt;sup id=&quot;fnref1&quot;&gt;&lt;a href=&quot;#fn1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;table class=&quot;table&quot;&gt;
        &lt;thead&gt;&lt;tr&gt;
&lt;th&gt;순위&lt;/th&gt;
&lt;th&gt;당첨 내용&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
        &lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;6개 번호가 모두 일치&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;5개 번호가 일치&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4개 번호가 일치&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;3개 번호가 일치&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;2개 번호가 일치&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6(낙첨)&lt;/td&gt;
&lt;td&gt;그 외&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
      &lt;/table&gt;
&lt;p&gt;로또를 구매한 민우는 당첨 번호 발표일을 학수고대하고 있었습니다. 하지만, 민우의 동생이 로또에 낙서를 하여, 일부 번호를 알아볼 수 없게 되었습니다. 당첨 번호 발표 후, 민우는 자신이 구매했던 로또로 당첨이 가능했던 최고 순위와 최저 순위를 알아보고 싶어 졌습니다. &lt;br /&gt;
알아볼 수 없는 번호를 &lt;code&gt;0&lt;/code&gt;으로 표기하기로 하고, 민우가 구매한 로또 번호 6개가 &lt;code&gt;44, 1, 0, 0, 31 25&lt;/code&gt;라고 가정해보겠습니다. 당첨 번호 6개가 &lt;code&gt;31, 10, 45, 1, 6, 19&lt;/code&gt;라면, 당첨 가능한 최고 순위와 최저 순위의 한 예는 아래와 같습니다.&lt;/p&gt;
&lt;table class=&quot;table&quot;&gt;
        &lt;thead&gt;&lt;tr&gt;
&lt;th&gt;당첨 번호&lt;/th&gt;
&lt;th&gt;31&lt;/th&gt;
&lt;th&gt;10&lt;/th&gt;
&lt;th&gt;45&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;19&lt;/th&gt;
&lt;th&gt;결과&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
        &lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;최고 순위 번호&lt;/td&gt;
&lt;td&gt;&lt;u&gt;&lt;strong&gt;31&lt;/strong&gt;&lt;/u&gt;&lt;/td&gt;
&lt;td&gt;0→&lt;u&gt;&lt;strong&gt;10&lt;/strong&gt;&lt;/u&gt;&lt;/td&gt;
&lt;td&gt;44&lt;/td&gt;
&lt;td&gt;&lt;u&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/u&gt;&lt;/td&gt;
&lt;td&gt;0→&lt;u&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;/u&gt;&lt;/td&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;4개 번호 일치, 3등&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;최저 순위 번호&lt;/td&gt;
&lt;td&gt;&lt;u&gt;&lt;strong&gt;31&lt;/strong&gt;&lt;/u&gt;&lt;/td&gt;
&lt;td&gt;0→11&lt;/td&gt;
&lt;td&gt;44&lt;/td&gt;
&lt;td&gt;&lt;u&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/u&gt;&lt;/td&gt;
&lt;td&gt;0→7&lt;/td&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;2개 번호 일치, 5등&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
      &lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;순서와 상관없이, 구매한 로또에 당첨 번호와 일치하는 번호가 있으면 맞힌 걸로 인정됩니다. &lt;/li&gt;
&lt;li&gt;알아볼 수 없는 두 개의 번호를 각각 10, 6이라고 가정하면 3등에 당첨될 수 있습니다. 

&lt;ul&gt;
&lt;li&gt;3등을 만드는 다른 방법들도 존재합니다. 하지만, 2등 이상으로 만드는 것은 불가능합니다. &lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;알아볼 수 없는 두 개의 번호를 각각 11, 7이라고 가정하면 5등에 당첨될 수 있습니다. 

&lt;ul&gt;
&lt;li&gt;5등을 만드는 다른 방법들도 존재합니다. 하지만, 6등(낙첨)으로 만드는 것은 불가능합니다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;민우가 구매한 로또 번호를 담은 배열 lottos, 당첨 번호를 담은 배열 win_nums가 매개변수로 주어집니다. 이때, 당첨 가능한 최고 순위와 최저 순위를 차례대로 배열에 담아서 return 하도록 solution 함수를 완성해주세요. &lt;/p&gt;

&lt;h5&gt;제한사항&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;lottos는 길이 6인 정수 배열입니다.&lt;/li&gt;
&lt;li&gt;lottos의 모든 원소는 0 이상 45 이하인 정수입니다.

&lt;ul&gt;
&lt;li&gt;0은 알아볼 수 없는 숫자를 의미합니다.&lt;/li&gt;
&lt;li&gt;0을 제외한 다른 숫자들은 lottos에 2개 이상 담겨있지 않습니다.&lt;/li&gt;
&lt;li&gt;lottos의 원소들은 정렬되어 있지 않을 수도 있습니다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;win_nums은 길이 6인 정수 배열입니다.&lt;/li&gt;
&lt;li&gt;win_nums의 모든 원소는 1 이상 45 이하인 정수입니다.

&lt;ul&gt;
&lt;li&gt;win_nums에는 같은 숫자가 2개 이상 담겨있지 않습니다.&lt;/li&gt;
&lt;li&gt;win_nums의 원소들은 정렬되어 있지 않을 수도 있습니다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h5&gt;입출력 예&lt;/h5&gt;
&lt;table class=&quot;table&quot;&gt;
        &lt;thead&gt;&lt;tr&gt;
&lt;th&gt;lottos&lt;/th&gt;
&lt;th&gt;win_nums&lt;/th&gt;
&lt;th&gt;result&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
        &lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;[44, 1, 0, 0, 31, 25]&lt;/td&gt;
&lt;td&gt;[31, 10, 45, 1, 6, 19]&lt;/td&gt;
&lt;td&gt;[3, 5]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[0, 0, 0, 0, 0, 0]&lt;/td&gt;
&lt;td&gt;[38, 19, 20, 40, 15, 25]&lt;/td&gt;
&lt;td&gt;[1, 6]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[45, 4, 35, 20, 3, 9]&lt;/td&gt;
&lt;td&gt;[20, 9, 3, 45, 4, 35]&lt;/td&gt;
&lt;td&gt;[1, 1]&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
      &lt;/table&gt;
&lt;h5&gt;입출력 예 설명&lt;/h5&gt;

&lt;p&gt;입출력 예 #1&lt;br /&gt;
문제 예시와 같습니다.&lt;/p&gt;

&lt;p&gt;입출력 예 #2&lt;br /&gt;
알아볼 수 없는 번호들이 아래와 같았다면, 1등과 6등에 당첨될 수 있습니다. &lt;/p&gt;
&lt;table class=&quot;table&quot;&gt;
        &lt;thead&gt;&lt;tr&gt;
&lt;th&gt;당첨 번호&lt;/th&gt;
&lt;th&gt;38&lt;/th&gt;
&lt;th&gt;19&lt;/th&gt;
&lt;th&gt;20&lt;/th&gt;
&lt;th&gt;40&lt;/th&gt;
&lt;th&gt;15&lt;/th&gt;
&lt;th&gt;25&lt;/th&gt;
&lt;th&gt;결과&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
        &lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;최고 순위 번호&lt;/td&gt;
&lt;td&gt;0→&lt;u&gt;&lt;strong&gt;38&lt;/strong&gt;&lt;/u&gt;&lt;/td&gt;
&lt;td&gt;0→&lt;u&gt;&lt;strong&gt;19&lt;/strong&gt;&lt;/u&gt;&lt;/td&gt;
&lt;td&gt;0→&lt;u&gt;&lt;strong&gt;20&lt;/strong&gt;&lt;/u&gt;&lt;/td&gt;
&lt;td&gt;0→&lt;u&gt;&lt;strong&gt;40&lt;/strong&gt;&lt;/u&gt;&lt;/td&gt;
&lt;td&gt;0→&lt;u&gt;&lt;strong&gt;15&lt;/strong&gt;&lt;/u&gt;&lt;/td&gt;
&lt;td&gt;0→&lt;u&gt;&lt;strong&gt;25&lt;/strong&gt;&lt;/u&gt;&lt;/td&gt;
&lt;td&gt;6개 번호 일치, 1등&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;최저 순위 번호&lt;/td&gt;
&lt;td&gt;0→21&lt;/td&gt;
&lt;td&gt;0→22&lt;/td&gt;
&lt;td&gt;0→23&lt;/td&gt;
&lt;td&gt;0→24&lt;/td&gt;
&lt;td&gt;0→26&lt;/td&gt;
&lt;td&gt;0→27&lt;/td&gt;
&lt;td&gt;0개 번호 일치, 6등&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
      &lt;/table&gt;
&lt;p&gt;입출력 예 #3&lt;br /&gt;
민우가 구매한 로또의 번호와 당첨 번호가 모두 일치하므로, 최고 순위와 최저 순위는 모두 1등입니다. &lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;

&lt;li id=&quot;fn1&quot;&gt;
&lt;p&gt;실제로 사용되는 로또 순위의 결정 방식과는 약간 다르지만, 이 문제에서는 지문에 명시된 대로 로또 순위를 결정하도록 합니다. &amp;nbsp;&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;/ol&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;2-해결방법-시간복잡도&quot;&gt;2. 해결방법 시간복잡도&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;단순 코딩 O(N)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-문제-해결-및-코드&quot;&gt;3. 문제 해결 및 코드&lt;/h2&gt;
&lt;hr /&gt;

&lt;script src=&quot;https://gist.github.com/godhin/fd6c1299d939d62517db232f47bc4de4.js&quot;&gt;&lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;주석을-참고하면서-이해를-돕습니다&quot;&gt;주석을 참고하면서 이해를 돕습니다.&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-알고리즘-및-해설&quot;&gt;4. 알고리즘 및 해설&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;문제에서 제시하는 로또의 등수 기준을 딕셔너리로 만들었다.&lt;/li&gt;
  &lt;li&gt;이후 두 변수를 만든 후 반복문을 통해 내가 쓴 로또번호가 당첨 번호에 있을 경우 변수에 값을 추가하는 방식이다.
    &lt;ul&gt;
      &lt;li&gt;이때 0인 경우는 당첨여부를 모르기때문에 행복회로(최고 순위)값에 추가해준다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이후 해당 값을 딕셔너리에서 찾아 출력하는 방식으로 풀었다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;5-짚고-넘어가기&quot;&gt;5. 짚고 넘어가기&lt;/h2&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;solution&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lottos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;win_nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;zero&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lottos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lottos&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;win_nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;max&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zero&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;min&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;nb&quot;&gt;max&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;max&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;max&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;min&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;min&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;min&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;[정답 출처 : 프로그래머스 다른 사람의 풀이]&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;다른 코드를 보았을 때 대부분 비슷하게 풀이하였으나, 이분의 경우 컴프리핸션과 count()함수를 사용해서 0값을 찾고 시작했다는 점이 인상깊었다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>You Nicholas</name></author><category term="코딩테스트" /><category term="알고리즘" /><category term="라이브코딩" /><category term="코테" /><category term="프로그래머스" /><category term="Level_1" /><summary type="html">프로그래머스 로또의 최고 순위와 최저 순위 문제 풀이</summary></entry><entry><title type="html">[파이썬][프로그래머스] 크레인 인형뽑기 게임</title><link href="http://localhost:4000/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/64061/" rel="alternate" type="text/html" title="[파이썬][프로그래머스] 크레인 인형뽑기 게임" /><published>2022-06-26T00:00:00+09:00</published><updated>2022-06-26T00:00:00+09:00</updated><id>http://localhost:4000/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/64061</id><content type="html" xml:base="http://localhost:4000/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/64061/">&lt;h2 id=&quot;1-문제&quot;&gt;1. 문제&lt;/h2&gt;

&lt;h1 id=&quot;level-1-크레인-인형뽑기-게임---64061&quot;&gt;[level 1] 크레인 인형뽑기 게임 - 64061&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/64061&quot;&gt;문제 링크&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;성능-요약&quot;&gt;성능 요약&lt;/h3&gt;

&lt;p&gt;메모리: 10.2 MB, 시간: 0.71 ms&lt;/p&gt;

&lt;h3 id=&quot;구분&quot;&gt;구분&lt;/h3&gt;

&lt;p&gt;코딩테스트 연습 &amp;gt; 2019 카카오 개발자 겨울 인턴십&lt;/p&gt;

&lt;h3 id=&quot;채점결과&quot;&gt;채점결과&lt;/h3&gt;

&lt;p&gt;&lt;br /&gt;정확성: 100.0&lt;br /&gt;합계: 100.0 / 100.0&lt;/p&gt;

&lt;h3 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h3&gt;

&lt;p&gt;게임개발자인 &quot;죠르디&quot;는 크레인 인형뽑기 기계를 모바일 게임으로 만들려고 합니다.&lt;br /&gt;
&quot;죠르디&quot;는 게임의 재미를 높이기 위해 화면 구성과 규칙을 다음과 같이 게임 로직에 반영하려고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/69f1cd36-09f4-4435-8363-b71a650f7448/crane_game_101.png&quot; title=&quot;&quot; alt=&quot;crane_game_101.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;게임 화면은 &lt;strong&gt;&quot;1 x 1&quot;&lt;/strong&gt; 크기의 칸들로 이루어진 &lt;strong&gt;&quot;N x N&quot;&lt;/strong&gt; 크기의 정사각 격자이며 위쪽에는 크레인이 있고 오른쪽에는 바구니가 있습니다. (위 그림은 &quot;5 x 5&quot; 크기의 예시입니다). 각 격자 칸에는 다양한 인형이 들어 있으며 인형이 없는 칸은 빈칸입니다. 모든 인형은 &quot;1 x 1&quot; 크기의 격자 한 칸을 차지하며 &lt;strong&gt;격자의 가장 아래 칸부터 차곡차곡 쌓여 있습니다.&lt;/strong&gt; 게임 사용자는 크레인을 좌우로 움직여서 멈춘 위치에서 가장 위에 있는 인형을 집어 올릴 수 있습니다. 집어 올린 인형은 바구니에 쌓이게 되는 데, 이때 바구니의 가장 아래 칸부터 인형이 순서대로 쌓이게 됩니다. 다음 그림은  [1번, 5번, 3번] 위치에서 순서대로 인형을 집어 올려 바구니에 담은 모습입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/638e2162-b1e4-4bbb-b0d7-62d31e97d75c/crane_game_102.png&quot; title=&quot;&quot; alt=&quot;crane_game_102.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;만약 같은 모양의 인형 두 개가 바구니에 연속해서 쌓이게 되면 두 인형은 터뜨려지면서 바구니에서 사라지게 됩니다. 위 상태에서 이어서 [5번] 위치에서 인형을 집어 바구니에 쌓으면 같은 모양 인형 &lt;strong&gt;두 개&lt;/strong&gt;가 없어집니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/8569d736-091e-4771-b2d3-7a6e95a20c22/crane_game_103.gif&quot; title=&quot;&quot; alt=&quot;crane_game_103.gif&quot; /&gt;&lt;/p&gt;

&lt;p&gt;크레인 작동 시 인형이 집어지지 않는 경우는 없으나 만약 인형이 없는 곳에서 크레인을 작동시키는 경우에는 아무런 일도 일어나지 않습니다. 또한 바구니는 모든 인형이  들어갈 수 있을 만큼 충분히 크다고 가정합니다. (그림에서는 화면표시 제약으로 5칸만으로 표현하였음)&lt;/p&gt;

&lt;p&gt;게임 화면의 격자의 상태가 담긴 2차원 배열 board와 인형을 집기 위해 크레인을 작동시킨 위치가 담긴 배열 moves가 매개변수로 주어질 때, 크레인을 모두 작동시킨 후 터트려져 사라진 인형의 개수를 return 하도록 solution 함수를 완성해주세요.&lt;/p&gt;

&lt;h5&gt;&lt;strong&gt;[제한사항]&lt;/strong&gt;&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;board 배열은 2차원 배열로 크기는 &quot;5 x 5&quot; 이상 &quot;30 x 30&quot; 이하입니다.&lt;/li&gt;
&lt;li&gt;board의 각 칸에는 0 이상 100 이하인 정수가 담겨있습니다.

&lt;ul&gt;
&lt;li&gt;0은 빈 칸을 나타냅니다.&lt;/li&gt;
&lt;li&gt;1 ~ 100의 각 숫자는 각기 다른 인형의 모양을 의미하며 같은 숫자는 같은 모양의 인형을 나타냅니다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;moves 배열의 크기는 1 이상 1,000 이하입니다.&lt;/li&gt;
&lt;li&gt;moves 배열 각 원소들의 값은 1 이상이며 board 배열의 가로 크기 이하인 자연수입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;&lt;strong&gt;입출력 예&lt;/strong&gt;&lt;/h5&gt;
&lt;table class=&quot;table&quot;&gt;
        &lt;thead&gt;&lt;tr&gt;
&lt;th&gt;board&lt;/th&gt;
&lt;th&gt;moves&lt;/th&gt;
&lt;th&gt;result&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
        &lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;[[0,0,0,0,0],[0,0,1,0,3],[0,2,5,0,1],[4,2,4,4,2],[3,5,1,3,1]]&lt;/td&gt;
&lt;td&gt;[1,5,3,5,1,2,1,4]&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
      &lt;/table&gt;
&lt;h5&gt;&lt;strong&gt;입출력 예에 대한 설명&lt;/strong&gt;&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;입출력 예 #1&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;인형의 처음 상태는 문제에 주어진 예시와 같습니다. 크레인이 [1, 5, 3, 5, 1, 2, 1, 4] 번 위치에서 차례대로 인형을 집어서 바구니에 옮겨 담은 후, 상태는 아래 그림과 같으며 바구니에 담는 과정에서 터트려져 사라진 인형은 4개 입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/bb0f59c7-6b72-485a-8302-217fe53ea88f/crane_game_104.jpg&quot; title=&quot;&quot; alt=&quot;crane_game_104.jpg&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;2-해결방법-시간복잡도&quot;&gt;2. 해결방법 시간복잡도&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;스택 O(N^2)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-문제-해결-및-코드&quot;&gt;3. 문제 해결 및 코드&lt;/h2&gt;
&lt;hr /&gt;

&lt;script src=&quot;https://gist.github.com/godhin/3d39a4402caef85886a9e792dfc8af7a.js&quot;&gt;&lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;주석을-참고하면서-이해를-돕습니다&quot;&gt;주석을 참고하면서 이해를 돕습니다.&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-알고리즘-및-해설&quot;&gt;4. 알고리즘 및 해설&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;크레인 뽑기의 핵심은 배열내에 해당 값을 찾아 스택에 쌓는 것이다.&lt;/li&gt;
  &lt;li&gt;moves라는 우리가 움직여야하는 손과 board라는 2차원 배열에서 해당 값을 찾아 만약 0이 아니라면 해당 값을 스택에 쌓는다.
    &lt;ul&gt;
      &lt;li&gt;0이 아닌 경우는 != 라고도 표현할 수 있으나 해당 문제에서는 0보다 크게 나와 &amp;gt; 라고 표현하였다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이후 내가 뽑은 위치값을 0으로 변경해준다. 삭제하는 방법도 있지만 이는 추후에 크레인이 해당 위치값을 또 찾으러 갈 때 값이 변경되어 있을 가능성을 배제하기 위해서 0으로 변경한다.
    &lt;ul&gt;
      &lt;li&gt;0이 아닌 삭제를 할 경우 뒤의 값이 앞으로 당겨져서 의도와는 다른 수를 찾게 되는 경우가 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스택에 마지막에 쌓인 값과 바로 앞에 쌓인 값이 같다면 pop()을 통해 빼준다.
    &lt;ul&gt;
      &lt;li&gt;문제에서는 2개가 같은 경우에 빼주기떄문에 결과값에 += 2를 해준다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;최종 결과값을 출력해준다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;5-짚고-넘어가기&quot;&gt;5. 짚고 넘어가기&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;문제를 해결하는 방법은 크게 2가지 정도가 있는 것같다.
    &lt;ul&gt;
      &lt;li&gt;단순 코딩 == 브루트 포스&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;스택&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;solution&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;board&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;moves&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cols&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)),&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;zip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;board&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;moves&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()):&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;extend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;[정답 출처 : 프로그래머스 다른 사람의 풀이]&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;다른 분이 푼 문제를 봤는데, 해당 문제를 lambda와 filter의 조화로 해결하여서 굉장히 인상깊었다. 이런 식으로 문제를 해결한다면 시간복잡도는 O(N)으로 기존보다 훨씬 메모리 효율이 좋을 것이라는 생각이 들었다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>You Nicholas</name></author><category term="코딩테스트" /><category term="알고리즘" /><category term="라이브코딩" /><category term="코테" /><category term="프로그래머스" /><category term="Level_1" /><summary type="html">프로그래머스 크레인 인형뽑기 게임 문제 풀이</summary></entry><entry><title type="html">[파이썬][Codility_][코디리티] TapeEquilibrium</title><link href="http://localhost:4000/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/TapeEquilibrium/" rel="alternate" type="text/html" title="[파이썬][Codility_][코디리티] TapeEquilibrium" /><published>2022-06-23T00:00:00+09:00</published><updated>2022-06-24T00:00:00+09:00</updated><id>http://localhost:4000/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/TapeEquilibrium</id><content type="html" xml:base="http://localhost:4000/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/TapeEquilibrium/">&lt;h2 id=&quot;1-문제&quot;&gt;1. 문제&lt;/h2&gt;

&lt;p&gt;A non-empty array A consisting of N integers is given. Array A represents numbers on a tape.&lt;/p&gt;

&lt;p&gt;Any integer P, such that 0 &amp;lt; P &amp;lt; N, splits this tape into two non-empty parts: A[0], A[1], …, A[P − 1] and A[P], A[P + 1], …, A[N − 1].&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;The difference between the two parts is the value of:&lt;/td&gt;
      &lt;td&gt;(A[0] + A[1] + … + A[P − 1]) − (A[P] + A[P + 1] + … + A[N − 1])&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;In other words, it is the absolute difference between the sum of the first part and the sum of the second part.&lt;/p&gt;

&lt;p&gt;For example, consider array A such that:&lt;/p&gt;

&lt;p&gt;A[0] = 3
  A[1] = 1
  A[2] = 2
  A[3] = 4
  A[4] = 3
We can split this tape in four places:&lt;/p&gt;

&lt;p&gt;P = 1, difference = |3 − 10| = 7
P = 2, difference = |4 − 9| = 5
P = 3, difference = |6 − 7| = 1
P = 4, difference = |10 − 3| = 7
Write a function:&lt;/p&gt;

&lt;p&gt;def solution(A)&lt;/p&gt;

&lt;p&gt;that, given a non-empty array A of N integers, returns the minimal difference that can be achieved.&lt;/p&gt;

&lt;p&gt;For example, given:&lt;/p&gt;

&lt;p&gt;A[0] = 3
  A[1] = 1
  A[2] = 2
  A[3] = 4
  A[4] = 3
the function should return 1, as explained above.&lt;/p&gt;

&lt;p&gt;Write an efficient algorithm for the following assumptions:&lt;/p&gt;

&lt;p&gt;N is an integer within the range [2..100,000];
each element of array A is an integer within the range [−1,000..1,000].
Copyright 2009–2022 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;출처: Codility_, https://app.codility.com/programmers/&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;2-해결방법-시간복잡도&quot;&gt;2. 해결방법 시간복잡도&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;단순 코딩 O(N)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-문제-해결-및-코드&quot;&gt;3. 문제 해결 및 코드&lt;/h2&gt;
&lt;hr /&gt;

&lt;script src=&quot;https://gist.github.com/godhin/49a2fb5ae8c51b4ffb7b83fbf11778b4.js&quot;&gt;&lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;주석을-참고하면서-이해를-돕습니다&quot;&gt;주석을 참고하면서 이해를 돕습니다.&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-알고리즘-및-해설&quot;&gt;4. 알고리즘 및 해설&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;문제의 요점은 P까지의 합과 P이후의 합의 차를 절대값으로 구하고, 모든 P의 수 중 가장 작은 값을 도출하는 것이다.&lt;/li&gt;
  &lt;li&gt;0이라는 값과 A 배열의 모든 합을 좌측 우측으로 지정해준다.
    &lt;ol&gt;
      &lt;li&gt;결과값은 None으로 지정해줘서 계속해서 업데이트 해준다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;반복문을 통해 좌 우측 값을 업데이트하고 값을 계산해서, min()을 통해 결과값들을 비교후 가장 작은 값을 도출해준다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;5-내가-처음-시도했던-방식&quot;&gt;5. 내가 처음 시도했던 방식&lt;/h2&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;abs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:]))&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;abs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:])),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;위와 같은 방법이나 리스트내에서 현재 위치 i 이전의 합과, 현재 위치 i 이후의 값을 계산한다는 점에서 시간복잡도가 높게 나온 것 같다.
    &lt;ul&gt;
      &lt;li&gt;해당 방식으로 해결한 결과 시간 복잡도 O(N*N)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>You Nicholas</name></author><category term="코딩테스트" /><category term="알고리즘" /><category term="라이브코딩" /><category term="코테" /><category term="Codility" /><category term="코디리티" /><category term="Lessons" /><summary type="html">Codility TapeEquilibrium 문제 풀이</summary></entry><entry><title type="html">[파이썬][Codility_][코디리티] FrogJmp</title><link href="http://localhost:4000/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/FrogJmp/" rel="alternate" type="text/html" title="[파이썬][Codility_][코디리티] FrogJmp" /><published>2022-06-23T00:00:00+09:00</published><updated>2022-06-24T00:00:00+09:00</updated><id>http://localhost:4000/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/FrogJmp</id><content type="html" xml:base="http://localhost:4000/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/FrogJmp/">&lt;h2 id=&quot;1-문제&quot;&gt;1. 문제&lt;/h2&gt;

&lt;p&gt;A small frog wants to get to the other side of the road. The frog is currently located at position X and wants to get to a position greater than or equal to Y. The small frog always jumps a fixed distance, D.&lt;/p&gt;

&lt;p&gt;Count the minimal number of jumps that the small frog must perform to reach its target.&lt;/p&gt;

&lt;p&gt;Write a function:&lt;/p&gt;

&lt;p&gt;def solution(X, Y, D)&lt;/p&gt;

&lt;p&gt;that, given three integers X, Y and D, returns the minimal number of jumps from position X to a position equal to or greater than Y.&lt;/p&gt;

&lt;p&gt;For example, given:&lt;/p&gt;

&lt;p&gt;X = 10
  Y = 85
  D = 30
the function should return 3, because the frog will be positioned as follows:&lt;/p&gt;

&lt;p&gt;after the first jump, at position 10 + 30 = 40
after the second jump, at position 10 + 30 + 30 = 70
after the third jump, at position 10 + 30 + 30 + 30 = 100
Write an efficient algorithm for the following assumptions:&lt;/p&gt;

&lt;p&gt;X, Y and D are integers within the range [1..1,000,000,000];
X ≤ Y.
Copyright 2009–2022 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;출처: Codility_, https://app.codility.com/programmers/&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;2-해결방법-시간복잡도&quot;&gt;2. 해결방법 시간복잡도&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;단순 코딩 O(1)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-문제-해결-및-코드&quot;&gt;3. 문제 해결 및 코드&lt;/h2&gt;
&lt;hr /&gt;

&lt;script src=&quot;https://gist.github.com/godhin/712e1f66446f2bf122be0cf7444ce152.js&quot;&gt;&lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;주석을-참고하면서-이해를-돕습니다&quot;&gt;주석을 참고하면서 이해를 돕습니다.&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-알고리즘-및-해설&quot;&gt;4. 알고리즘 및 해설&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;문제의 요점은 개구리가 현재 위치에서 목표지점까지 몇 번을 뛰어야하냐는 것이다.&lt;/li&gt;
  &lt;li&gt;목표지점까지의 거리를 점프하는 거리로 나누어주되, 그 값을 반올림해준다.
    &lt;ul&gt;
      &lt;li&gt;소수점단위로 뛸 수는 없기떄문에 math.ceil() 함수를 이용해서 반올림한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;5-알아두면-좋은-정보&quot;&gt;5. 알아두면 좋은 정보&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;문제 자체는 간단하나 &lt;em&gt;math&lt;/em&gt; 라이브러리를 사용해서 보다 쉽게 문제 해결이 가능하다.&lt;/li&gt;
&lt;/ol&gt;</content><author><name>You Nicholas</name></author><category term="코딩테스트" /><category term="알고리즘" /><category term="라이브코딩" /><category term="코테" /><category term="Codility" /><category term="코디리티" /><category term="Lessons" /><summary type="html">Codility FrogJmp 문제 풀이</summary></entry><entry><title type="html">[파이썬][Codility_][코디리티] PermMissingElem</title><link href="http://localhost:4000/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/PermMissingElem/" rel="alternate" type="text/html" title="[파이썬][Codility_][코디리티] PermMissingElem" /><published>2022-06-23T00:00:00+09:00</published><updated>2022-06-24T00:00:00+09:00</updated><id>http://localhost:4000/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/PermMissingElem</id><content type="html" xml:base="http://localhost:4000/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/PermMissingElem/">&lt;h2 id=&quot;1-문제&quot;&gt;1. 문제&lt;/h2&gt;

&lt;p&gt;Task description
An array A consisting of N different integers is given. The array contains integers in the range [1..(N + 1)], which means that exactly one element is missing.&lt;/p&gt;

&lt;p&gt;Your goal is to find that missing element.&lt;/p&gt;

&lt;p&gt;Write a function:&lt;/p&gt;

&lt;p&gt;def solution(A)&lt;/p&gt;

&lt;p&gt;that, given an array A, returns the value of the missing element.&lt;/p&gt;

&lt;p&gt;For example, given array A such that:&lt;/p&gt;

&lt;p&gt;A[0] = 2
  A[1] = 3
  A[2] = 1
  A[3] = 5
the function should return 4, as it is the missing element.&lt;/p&gt;

&lt;p&gt;Write an efficient algorithm for the following assumptions:&lt;/p&gt;

&lt;p&gt;N is an integer within the range [0..100,000];
the elements of A are all distinct;
each element of array A is an integer within the range [1..(N + 1)].
Copyright 2009–2022 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;출처: Codility_, https://app.codility.com/programmers/&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;2-해결방법-시간복잡도&quot;&gt;2. 해결방법 시간복잡도&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;단순 코딩 O(N) or O(Nlog(N))&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-문제-해결-및-코드&quot;&gt;3. 문제 해결 및 코드&lt;/h2&gt;
&lt;hr /&gt;

&lt;script src=&quot;https://gist.github.com/godhin/5afa6fba851afcc2151af39c0909989b.js&quot;&gt;&lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;주석을-참고하면서-이해를-돕습니다&quot;&gt;주석을 참고하면서 이해를 돕습니다.&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-알고리즘-및-해설&quot;&gt;4. 알고리즘 및 해설&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;문제의 요점은 순차적으로 증가하는 배열에서 규칙에 맞지않는 수를 찾는 것이다.&lt;/li&gt;
  &lt;li&gt;내가 사용한 방법은 해당 규칙의 모든 수의 합 - 배열의 합을 한 것이다.
    &lt;ul&gt;
      &lt;li&gt;이때 예외처리를 해야하는 것은 배열이 없는 경우는 1로 출력한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>You Nicholas</name></author><category term="코딩테스트" /><category term="알고리즘" /><category term="라이브코딩" /><category term="코테" /><category term="Codility" /><category term="코디리티" /><category term="Lessons" /><summary type="html">Codility PermMissingElem 문제 풀이</summary></entry><entry><title type="html">[파이썬][Codility_][코디리티] OddOccurrencesInArray</title><link href="http://localhost:4000/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/OddOccurrencesInArray/" rel="alternate" type="text/html" title="[파이썬][Codility_][코디리티] OddOccurrencesInArray" /><published>2022-06-22T00:00:00+09:00</published><updated>2022-06-23T00:00:00+09:00</updated><id>http://localhost:4000/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/OddOccurrencesInArray</id><content type="html" xml:base="http://localhost:4000/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/OddOccurrencesInArray/">&lt;h2 id=&quot;1-문제&quot;&gt;1. 문제&lt;/h2&gt;

&lt;p&gt;A non-empty array A consisting of N integers is given. The array contains an odd number of elements, and each element of the array can be paired with another element that has the same value, except for one element that is left unpaired.&lt;/p&gt;

&lt;p&gt;For example, in array A such that:&lt;/p&gt;

&lt;p&gt;A[0] = 9  A[1] = 3  A[2] = 9
  A[3] = 3  A[4] = 9  A[5] = 7
  A[6] = 9
the elements at indexes 0 and 2 have value 9,
the elements at indexes 1 and 3 have value 3,
the elements at indexes 4 and 6 have value 9,
the element at index 5 has value 7 and is unpaired.
Write a function:&lt;/p&gt;

&lt;p&gt;def solution(A)&lt;/p&gt;

&lt;p&gt;that, given an array A consisting of N integers fulfilling the above conditions, returns the value of the unpaired element.&lt;/p&gt;

&lt;p&gt;For example, given array A such that:&lt;/p&gt;

&lt;p&gt;A[0] = 9  A[1] = 3  A[2] = 9
  A[3] = 3  A[4] = 9  A[5] = 7
  A[6] = 9
the function should return 7, as explained in the example above.&lt;/p&gt;

&lt;p&gt;Write an efficient algorithm for the following assumptions:&lt;/p&gt;

&lt;p&gt;N is an odd integer within the range [1..1,000,000];
each element of array A is an integer within the range [1..1,000,000,000];
all but one of the values in A occur an even number of times.
Copyright 2009–2022 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;출처: Codility_, https://app.codility.com/programmers/&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;2-해결방법-시간복잡도&quot;&gt;2. 해결방법 시간복잡도&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;단순 코딩 O(N) or O(Nlog(N))&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-문제-해결-및-코드&quot;&gt;3. 문제 해결 및 코드&lt;/h2&gt;
&lt;hr /&gt;

&lt;script src=&quot;https://gist.github.com/godhin/3ee3497ab7d98a79783abfd495e55a2d.js&quot;&gt;&lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;주석을-참고하면서-이해를-돕습니다&quot;&gt;주석을 참고하면서 이해를 돕습니다.&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-알고리즘-및-해설&quot;&gt;4. 알고리즘 및 해설&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;해당 문제의 요점은 리스트내 짝을 이루는 값이 있는 지 확인하는 것이다.&lt;/li&gt;
  &lt;li&gt;짝을 이룬다 == 해당 값이 2의 배수이다. 이므로 리스트를 정렬해준다.&lt;/li&gt;
  &lt;li&gt;정렬된 리스트를 반복문을 통해 경우에 따라 값을 출력한다.
    &lt;ul&gt;
      &lt;li&gt;경우 1. 짝수이므로 해당 위치 + 1이 마지막인 경우에는 홀수이므로 출력&lt;/li&gt;
      &lt;li&gt;경우 2. 해당 위치값과 다음 값이 다른 경우에는 해당 위치값이 짝이 없는 것이므로 출력&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;5-알아두면-좋은-정보&quot;&gt;5. 알아두면 좋은 정보&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;sort()또는 sorted()&lt;/strong&gt; 함수의 경우 버블과 같이 느린 방식이 아닌 최적화된 정렬 알고리즘 방식을 사용하기 때문에 시간복잡도가 O(nlogn)이 된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;정렬 알고리즘 문제 해결에 참고한 블로그 : &lt;a href=&quot;'http://www.secmem.org/blog/2019/04/10/special-sorts/'&quot;&gt;djm03178&lt;/a&gt;&lt;/p&gt;</content><author><name>You Nicholas</name></author><category term="코딩테스트" /><category term="알고리즘" /><category term="라이브코딩" /><category term="코테" /><category term="Codility" /><category term="코디리티" /><category term="Lessons" /><summary type="html">Codility OddOccurrencesInArray 문제 풀이</summary></entry><entry><title type="html">[파이썬][Codility_][코디리티] CyclicRotation</title><link href="http://localhost:4000/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/CyclicRotation/" rel="alternate" type="text/html" title="[파이썬][Codility_][코디리티] CyclicRotation" /><published>2022-06-22T00:00:00+09:00</published><updated>2022-06-23T00:00:00+09:00</updated><id>http://localhost:4000/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/CyclicRotation</id><content type="html" xml:base="http://localhost:4000/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/CyclicRotation/">&lt;h2 id=&quot;1-문제&quot;&gt;1. 문제&lt;/h2&gt;

&lt;p&gt;An array A consisting of N integers is given. Rotation of the array means that each element is shifted right by one index, and the last element of the array is moved to the first place. For example, the rotation of array A = [3, 8, 9, 7, 6] is [6, 3, 8, 9, 7] (elements are shifted right by one index and 6 is moved to the first place).&lt;/p&gt;

&lt;p&gt;The goal is to rotate array A K times; that is, each element of A will be shifted to the right K times.&lt;/p&gt;

&lt;p&gt;Write a function:&lt;/p&gt;

&lt;p&gt;def solution(A, K)&lt;/p&gt;

&lt;p&gt;that, given an array A consisting of N integers and an integer K, returns the array A rotated K times.&lt;/p&gt;

&lt;p&gt;For example, given&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;A = [3, 8, 9, 7, 6]
K = 3 the function should return [9, 7, 6, 3, 8]. Three rotations were made:

[3, 8, 9, 7, 6] -&amp;gt; [6, 3, 8, 9, 7]
[6, 3, 8, 9, 7] -&amp;gt; [7, 6, 3, 8, 9]
[7, 6, 3, 8, 9] -&amp;gt; [9, 7, 6, 3, 8] For another example, given

A = [0, 0, 0]
K = 1 the function should return [0, 0, 0]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Given&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;A = [1, 2, 3, 4]
K = 4 the function should return [1, 2, 3, 4]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Assume that:&lt;/p&gt;

&lt;p&gt;N and K are integers within the range [0..100];
each element of array A is an integer within the range [−1,000..1,000].
In your solution, focus on correctness. The performance of your solution will not be the focus of the assessment.&lt;/p&gt;

&lt;p&gt;Copyright 2009–2022 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;출처: Codility_, https://app.codility.com/programmers/&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;2-해결방법-시간복잡도&quot;&gt;2. 해결방법 시간복잡도&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;덱(deque) O(1)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-문제-해결-및-코드&quot;&gt;3. 문제 해결 및 코드&lt;/h2&gt;
&lt;hr /&gt;

&lt;script src=&quot;https://gist.github.com/godhin/ef883c5fa2f2e33ef23bba0c5606a8ae.js&quot;&gt;&lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;주석을-참고하면서-이해를-돕습니다&quot;&gt;주석을 참고하면서 이해를 돕습니다.&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-알고리즘-및-해설&quot;&gt;4. 알고리즘 및 해설&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;해당 문제의 경우 리스트내 값을 뒤에서 앞으로 바꿔오는 게 핵심이다.&lt;/li&gt;
  &lt;li&gt;deque를 통해 제일 뒤에 값을 앞에 만들어주고, 제일 뒤에 값을 빼는 형식으로 구현해봤다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;5-파이썬-deque-구현&quot;&gt;5. 파이썬 deque 구현&lt;/h2&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;collections&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;deque&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 덱 라이브러리
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;solution&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;deque&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 덱 형태로 변환
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>You Nicholas</name></author><category term="코딩테스트" /><category term="알고리즘" /><category term="라이브코딩" /><category term="코테" /><category term="Codility" /><category term="코디리티" /><category term="Lessons" /><summary type="html">Codility CyclicRotation 문제 풀이</summary></entry><entry><title type="html">[파이썬][Codility_][코디리티] BinaryGap</title><link href="http://localhost:4000/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/BinaryGap/" rel="alternate" type="text/html" title="[파이썬][Codility_][코디리티] BinaryGap" /><published>2022-06-22T00:00:00+09:00</published><updated>2022-06-22T00:00:00+09:00</updated><id>http://localhost:4000/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/BinaryGap</id><content type="html" xml:base="http://localhost:4000/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/BinaryGap/">&lt;h2 id=&quot;1-문제&quot;&gt;1. 문제&lt;/h2&gt;

&lt;p&gt;A binary gap within a positive integer N is any maximal sequence of consecutive zeros that is surrounded by ones at both ends in the binary representation of N.&lt;/p&gt;

&lt;p&gt;For example, number 9 has binary representation 1001 and contains a binary gap of length 2. The number 529 has binary representation 1000010001 and contains two binary gaps: one of length 4 and one of length 3. The number 20 has binary representation 10100 and contains one binary gap of length 1. The number 15 has binary representation 1111 and has no binary gaps. The number 32 has binary representation 100000 and has no binary gaps.&lt;/p&gt;

&lt;p&gt;Write a function:&lt;/p&gt;

&lt;p&gt;def solution(N)&lt;/p&gt;

&lt;p&gt;that, given a positive integer N, returns the length of its longest binary gap. The function should return 0 if N doesn’t contain a binary gap.&lt;/p&gt;

&lt;p&gt;For example, given N = 1041 the function should return 5, because N has binary representation 10000010001 and so its longest binary gap is of length 5. Given N = 32 the function should return 0, because N has binary representation ‘100000’ and thus no binary gaps.&lt;/p&gt;

&lt;p&gt;Write an efficient algorithm for the following assumptions:&lt;/p&gt;

&lt;p&gt;N is an integer within the range [1..2,147,483,647].
Copyright 2009–2022 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;출처: Codility_, https://app.codility.com/programmers/&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;2-해결방법-시간복잡도&quot;&gt;2. 해결방법 시간복잡도&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;단순 코딩 O(1)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-문제-해결-및-코드&quot;&gt;3. 문제 해결 및 코드&lt;/h2&gt;
&lt;hr /&gt;

&lt;script src=&quot;https://gist.github.com/godhin/334cd7a9c941c122e1b003be1f21228b.js&quot;&gt;&lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;주석을-참고하면서-이해를-돕습니다&quot;&gt;주석을 참고하면서 이해를 돕습니다.&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-알고리즘-및-해설&quot;&gt;4. 알고리즘 및 해설&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;bin() 함수를 통해 해당 문자열을 이진수로 바꿔준다.&lt;/li&gt;
  &lt;li&gt;strip()으로 좌우측 0과 1을 제외해준다.
    &lt;ul&gt;
      &lt;li&gt;해당 문제에서 말하는 바이너리 갭은 110011처럼 숫자 사이에 낀 것을 뜻한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이후 반복되는 수중 가장 길이가 긴 문자열의 길이를 출력한다.&lt;/li&gt;
&lt;/ol&gt;</content><author><name>You Nicholas</name></author><category term="코딩테스트" /><category term="알고리즘" /><category term="라이브코딩" /><category term="코테" /><category term="Codility" /><category term="코디리티" /><category term="Lessons" /><summary type="html">Codility BinaryGap 문제 풀이</summary></entry><entry><title type="html">[파이썬][Codility_][코디리티] FuryRoad</title><link href="http://localhost:4000/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/FuryRoad/" rel="alternate" type="text/html" title="[파이썬][Codility_][코디리티] FuryRoad" /><published>2022-06-22T00:00:00+09:00</published><updated>2022-06-23T00:00:00+09:00</updated><id>http://localhost:4000/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/FuryRoad</id><content type="html" xml:base="http://localhost:4000/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/FuryRoad/">&lt;h2 id=&quot;0-챌린지-소개&quot;&gt;0. 챌린지 소개&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/75519839/175105370-bb96a64a-f99d-4138-8810-d788d154689d.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;1-문제&quot;&gt;1. 문제&lt;/h2&gt;

&lt;p&gt;You have to be at your work as soon as possible. The road on your route to work may consist of two types of surface: asphalt or sand. To simplify the description, it will be denoted by a string R consisting only of the letters: “A” for an asphalt segment and “S” for a sand segment. All segments represent the same distance. For example, R = “SAAS” describes a road comprising of sand, asphalt, asphalt and sand segments.&lt;/p&gt;

&lt;p&gt;When you go on foot, you need 20 minutes to pass through an asphalt segment and 30 minutes through a sand segment. You also have an electric scooter, which needs 5 minutes to pass through an asphalt segment and 40 minutes through a sand segment.&lt;/p&gt;

&lt;p&gt;You start your journey on the scooter, but at any point you can get off the scooter and go on foot for the rest of the journey. What is the shortest time in which you can get to work?&lt;/p&gt;

&lt;p&gt;Write a function:&lt;/p&gt;

&lt;p&gt;def solution(R)&lt;/p&gt;

&lt;p&gt;that, given a string R of length N, representing the road to work, returns the minimum time that you need to get to work.&lt;/p&gt;

&lt;p&gt;Examples:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Given R = “ASAASS”, your function should return 115. You ride on the scooter over the first four segments (“ASAA”) in 5 + 40 + 5 + 5 = 55 and then you go on foot through “SS” in 30 + 30 = 60. Altogether, your journey will take 55 + 60 = 115.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Given R = “SSA”, the function should return 80. You do not ride on the scooter at all, and you go on foot in 30 + 30 + 20 = 80.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Given R = “SSSSAAA”, the function should return 175. You ride on the scooter all the time in 40 + 40 + 40 + 40 + 5 + 5 + 5 = 175.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Write an efficient algorithm for the following assumptions:&lt;/p&gt;

&lt;p&gt;N is an integer within the range [1..100,000];
string R consists only of the characters “S” and/or “A”.
Copyright 2009–2022 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;출처: Codility_, https://app.codility.com/programmers/&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;2-해결방법-시간복잡도&quot;&gt;2. 해결방법 시간복잡도&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;단순 코딩 O(N)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-문제-해결-및-코드&quot;&gt;3. 문제 해결 및 코드&lt;/h2&gt;
&lt;hr /&gt;

&lt;script src=&quot;https://gist.github.com/godhin/626d86140fbd84e219dd45731e965877.js&quot;&gt;&lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;주석을-참고하면서-이해를-돕습니다&quot;&gt;주석을 참고하면서 이해를 돕습니다.&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-알고리즘-및-해설&quot;&gt;4. 알고리즘 및 해설&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;문제의 요점은 2가지 이동수단을 통해 움직이는 것이다.
    &lt;ul&gt;
      &lt;li&gt;도보로 이동하는 경우
        &lt;ul&gt;
          &lt;li&gt;아스팔트 20분&lt;/li&gt;
          &lt;li&gt;모래 30분&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;스쿠터로 이동하는 경우
        &lt;ul&gt;
          &lt;li&gt;아스팔트 5분&lt;/li&gt;
          &lt;li&gt;모래 40분&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스쿠터의 경우 중간에 내리면 더 이상 사용할 수 없다는 점을 이용해서 도보로만 가는 경우를 만들었다.
    &lt;ul&gt;
      &lt;li&gt;이때 아스팔트 A와 모래 S를 숫자로 변환해서 리스트로 넣었다. -&amp;gt; 이는 도보로만 이동한 경우의 총합 시간을 구하기 위해서이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이후 반복문을 통해 스쿠터로 지나가는 모든 경우의 총합 시간을 리스트에 넣는다.
    &lt;ul&gt;
      &lt;li&gt;스쿠터가 해당 위치를 지나갈 때마다 스쿠터로 이동하는 시간으로 변경해준다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;그 중 가장 적게 걸린 시간을 출력한다.&lt;/li&gt;
&lt;/ol&gt;</content><author><name>You Nicholas</name></author><category term="코딩테스트" /><category term="알고리즘" /><category term="라이브코딩" /><category term="코테" /><category term="Codility" /><category term="코디리티" /><category term="Codility Challenge" /><summary type="html">Codility FuryRoad 문제 풀이</summary></entry><entry><title type="html">[파이썬][프로그래머스] 폰켓몬</title><link href="http://localhost:4000/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/1845/" rel="alternate" type="text/html" title="[파이썬][프로그래머스] 폰켓몬" /><published>2022-06-21T00:00:00+09:00</published><updated>2022-06-21T00:00:00+09:00</updated><id>http://localhost:4000/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/1845</id><content type="html" xml:base="http://localhost:4000/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/1845/">&lt;h2 id=&quot;1-문제&quot;&gt;1. 문제&lt;/h2&gt;

&lt;h1 id=&quot;level-1-폰켓몬---1845&quot;&gt;[level 1] 폰켓몬 - 1845&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/1845&quot;&gt;문제 링크&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;성능-요약&quot;&gt;성능 요약&lt;/h3&gt;

&lt;p&gt;메모리: 10.3 MB, 시간: 0.19 ms&lt;/p&gt;

&lt;h3 id=&quot;구분&quot;&gt;구분&lt;/h3&gt;

&lt;p&gt;코딩테스트 연습 &amp;gt; 찾아라 프로그래밍 마에스터&lt;/p&gt;

&lt;h3 id=&quot;채점결과&quot;&gt;채점결과&lt;/h3&gt;

&lt;p&gt;&lt;br /&gt;정확성: 100.0&lt;br /&gt;합계: 100.0 / 100.0&lt;/p&gt;

&lt;h3 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h3&gt;

&lt;p&gt;당신은 폰켓몬을 잡기 위한 오랜 여행 끝에, 홍 박사님의 연구실에 도착했습니다. 홍 박사님은 당신에게 자신의 연구실에 있는 총 N 마리의 폰켓몬 중에서 N/2마리를 가져가도 좋다고 했습니다.&lt;br /&gt;
홍 박사님 연구실의 폰켓몬은 종류에 따라 번호를 붙여 구분합니다. 따라서 같은 종류의 폰켓몬은 같은 번호를 가지고 있습니다. 예를 들어 연구실에 총 4마리의 폰켓몬이 있고, 각 폰켓몬의 종류 번호가 [3번, 1번, 2번, 3번]이라면 이는 3번 폰켓몬 두 마리, 1번 폰켓몬 한 마리, 2번 폰켓몬 한 마리가 있음을 나타냅니다. 이때, 4마리의 폰켓몬 중 2마리를 고르는 방법은 다음과 같이 6가지가 있습니다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;첫 번째(3번), 두 번째(1번) 폰켓몬을 선택&lt;/li&gt;
&lt;li&gt;첫 번째(3번), 세 번째(2번) 폰켓몬을 선택&lt;/li&gt;
&lt;li&gt;첫 번째(3번), 네 번째(3번) 폰켓몬을 선택&lt;/li&gt;
&lt;li&gt;두 번째(1번), 세 번째(2번) 폰켓몬을 선택&lt;/li&gt;
&lt;li&gt;두 번째(1번), 네 번째(3번) 폰켓몬을 선택&lt;/li&gt;
&lt;li&gt;세 번째(2번), 네 번째(3번) 폰켓몬을 선택&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이때, 첫 번째(3번) 폰켓몬과 네 번째(3번) 폰켓몬을 선택하는 방법은 한 종류(3번 폰켓몬 두 마리)의 폰켓몬만 가질 수 있지만, 다른 방법들은 모두 두 종류의 폰켓몬을 가질 수 있습니다. 따라서 위 예시에서 가질 수 있는 폰켓몬 종류 수의 최댓값은 2가 됩니다.&lt;br /&gt;
당신은 최대한 다양한 종류의 폰켓몬을 가지길 원하기 때문에, 최대한 많은 종류의 폰켓몬을 포함해서 N/2마리를 선택하려 합니다. N마리 폰켓몬의 종류 번호가 담긴 배열 nums가 매개변수로 주어질 때, N/2마리의 폰켓몬을 선택하는 방법 중, 가장 많은 종류의 폰켓몬을 선택하는 방법을 찾아, 그때의 폰켓몬 종류 번호의 개수를 return 하도록 solution 함수를 완성해주세요.&lt;/p&gt;

&lt;h5&gt;제한사항&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;nums는 폰켓몬의 종류 번호가 담긴 1차원 배열입니다.&lt;/li&gt;
&lt;li&gt;nums의 길이(N)는 1 이상 10,000 이하의 자연수이며, 항상 짝수로 주어집니다.&lt;/li&gt;
&lt;li&gt;폰켓몬의 종류 번호는 1 이상 200,000 이하의 자연수로 나타냅니다.&lt;/li&gt;
&lt;li&gt;가장 많은 종류의 폰켓몬을 선택하는 방법이 여러 가지인 경우에도, 선택할 수 있는 폰켓몬 종류 개수의 최댓값 하나만 return 하면 됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h5&gt;입출력 예&lt;/h5&gt;
&lt;table class=&quot;table&quot;&gt;
        &lt;thead&gt;&lt;tr&gt;
&lt;th&gt;nums&lt;/th&gt;
&lt;th&gt;result&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
        &lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;[3,1,2,3]&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[3,3,3,2,2,4]&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[3,3,3,2,2,2]&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
      &lt;/table&gt;
&lt;h5&gt;입출력 예 설명&lt;/h5&gt;

&lt;p&gt;입출력 예 #1&lt;br /&gt;
문제의 예시와 같습니다.&lt;/p&gt;

&lt;p&gt;입출력 예 #2&lt;br /&gt;
6마리의 폰켓몬이 있으므로, 3마리의 폰켓몬을 골라야 합니다.&lt;br /&gt;
가장 많은 종류의 폰켓몬을 고르기 위해서는 3번 폰켓몬 한 마리, 2번 폰켓몬 한 마리, 4번 폰켓몬 한 마리를 고르면 되며, 따라서 3을 return 합니다.&lt;/p&gt;

&lt;p&gt;입출력 예 #3&lt;br /&gt;
6마리의 폰켓몬이 있으므로, 3마리의 폰켓몬을 골라야 합니다.&lt;br /&gt;
가장 많은 종류의 폰켓몬을 고르기 위해서는 3번 폰켓몬 한 마리와 2번 폰켓몬 두 마리를 고르거나, 혹은 3번 폰켓몬 두 마리와 2번 폰켓몬 한 마리를 고르면 됩니다. 따라서 최대 고를 수 있는 폰켓몬 종류의 수는 2입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;2-해결방법-시간복잡도&quot;&gt;2. 해결방법 시간복잡도&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;단순 코딩 O(N)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-문제-해결-및-코드&quot;&gt;3. 문제 해결 및 코드&lt;/h2&gt;
&lt;hr /&gt;

&lt;script src=&quot;https://gist.github.com/godhin/b954c7fddb54276a3395eb98cbe00ea9.js&quot;&gt;&lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;주석을-참고하면서-이해를-돕습니다&quot;&gt;주석을 참고하면서 이해를 돕습니다.&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-알고리즘-및-해설&quot;&gt;4. 알고리즘 및 해설&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;총 폰켓몬 종류를 구하는 문제로 가지고 있는 폰켓몬의 N/2 숫자만큼 선택이 가능하다.&lt;/li&gt;
  &lt;li&gt;그 중 나올 수 있는 경우의 수를 구하는 문제이다.&lt;/li&gt;
  &lt;li&gt;문제를 더 간단하게 정리하자면, [3, 1, 2, 3] 총 4마리의 폰켓몬이 있다.
    &lt;ul&gt;
      &lt;li&gt;폰켓몬은 4마리이므로 N/2는 2마리까지 선택이 가능하다.&lt;/li&gt;
      &lt;li&gt;경우의 수는 [3, 1], [3, 2], [3, 3], [1, 2], [1, 3], [2, 3]&lt;/li&gt;
      &lt;li&gt;이 중 중복을 제외한 4가지 [1, 3], [2, 3], [3, 3], [1, 2]&lt;/li&gt;
      &lt;li&gt;서로 다른 2종류의 폰켓몬을 고르는 경우 1가지, 같은 종류의 폰켓몬을 고르는 경우 1가지&lt;/li&gt;
      &lt;li&gt;총 2가지이므로 답은 2&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;내가 선택한 방법은 중복을 제거한 반복문이 돌아가는 동안, 한번에 선택할 수 있는 폰켓몬 경우의 수를 세는 것이다.
    &lt;ul&gt;
      &lt;li&gt;반복문이 도는 동안 중복을 제외한 [3, 1, 2], 가질 수 있는 폰켓몬 2마리&lt;/li&gt;
      &lt;li&gt;총 3번의 반복을 하는 동안 가질 수 있는 폰켓몬 종류 번호의 개수보다 크다면 + 1&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>You Nicholas</name></author><category term="코딩테스트" /><category term="알고리즘" /><category term="라이브코딩" /><category term="코테" /><category term="프로그래머스" /><category term="Level_1" /><summary type="html">프로그래머스 폰켓몬 문제 풀이</summary></entry></feed>